<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js and the geo projection plugin -->
<script type="text/javascript" src="https://mbostock.github.com/d3/d3.js?2.4.5"></script>
<script src="https://d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-geo-projection.v2.min.js"></script>
<script src="https://kit.fontawesome.com/786166de9a.js" crossorigin="anonymous"></script>
<link rel="stylesheet" type="text/css" href="style.css">
<!-- <script src defer="filter_data.js"></script>
<script src defer="updateTable.js"></script>
<script src defer="createPieDataSets.js"></script>
<script src defer="drawPie.js"></script>
<script src defer="filterPie.js"></script> -->





    <body>

        <div class="column-3">
            <div class="div_RootBody" id="pie_chart_1">
                <h3 class="h3_Body">Industry Pie</h3>
                <div class="chart"></div>
            </div>
        </div>
        
        
        <div class="column-3">
            <div class="div_RootBody" id="pie_chart_2">
                <h3 class="h3_Body">Satus Pie</h3>
                <div class="chart"></div>
            </div>
        </div>
        
        
        <div class="column-3">
            <div class="div_RootBody" id="pie_chart_3">
                <h3 class="h3_Body">Intervention Pie</h3>
                <div class="chart"></div>
            </div>
        </div>

        <div id="all-checkboxes" class="column-2">
            <div id="industry-checks" class="column-3-boxes">
                <strong>
                    <p>Industry</p>
                </strong>
                <input class="checks" type="checkbox" value="Sponsor_Type" name="Industry">
                <label for="Industry">Industry</label><br>
                <input class="checks" type="checkbox" value="Sponsor_Type" name="Non-Industry">
                <label for="Non-Industry">Non-Industry</label>
            </div>
        
            <div id="status-checks" class="column-3">
                <strong>
                    <p>Status</p>
                </strong>
                <input class="checks" type="checkbox" value="Status" name="Completed">
                <label for="Completed">Completed</label><br>
                <input class="checks" type="checkbox" value="Status" name="Terminated">
                <label for="Terminated">Terminated</label><br>
                <input class="checks" type="checkbox" value="Status" name="Recruiting">
                <label for="Completed">Recruiting</label><br>
                <input class="checks" type="checkbox" value="Status" name="Active, not recruiting">
                <label for="Active, not recruiting">Active, not recruiting</label><br>
                <input class="checks" type="checkbox" value="Status" name="Unknown status">
                <label for="Unknown status">Unknown Status</label><br>
                <input class="checks" type="checkbox" value="Status" name="Not yet recruiting">
                <label for="Not yet recruiting">Not yet recruiting</label><br>
                <input class="checks" type="checkbox" value="Status" name="Withdrawn">
                <label for="Withdrawn">Withdrawn</label><br>
                <input class="checks" type="checkbox" value="Status" name="Enrolling by invitation">
                <label for="Enrolling by invitation">Enrolling by invitation</label>
            </div>
        
            <div id="intervention-checks" class="column-3">
                <strong>
                    <p>Intervention Types</p>
                </strong>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Drug">
                <label for="Drug">Drug</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Biological">
                <label for="Biological">Biological</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Device">
                <label for="Device">Device</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Behavioral">
                <label for="Behavioral">Behavioral</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Dietary Supplement">
                <label for="Dietary Supplement">Dietary Supplement</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Procedure">
                <label for="Procedure">Procedure</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Radiation">
                <label for="Radiation">Radiation</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Genetic">
                <label for="Genetic">Genetic</label><br>
                <input class="checks" type="checkbox" value="Intervention_Types" name="Other">
                <label for="Other">Other</label><br>
            </div>
        </div>
        <div class="place">
        </div>
        <svg id="my_dataviz" width="600" height="100"></svg>

        
        

    </body>
    <!-- Create an element where the table will take place -->



    <script>
        var newData;
        var pie_clicked = [];
        var data;

        // The svg
        var svg = d3.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

        // Define the div for the tooltip
        var div = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);


        


        d3.csv('lupus.csv', function (data) {
            data = data;
            

            var table = d3.select('.place').append("table");


            table = d3.selectAll("table");
            table.attr("id", "main-table");



            d3.selectAll(".checks").on("change", runall);
            updateTable(data);


            var pie_data = createPieDataSets(data);
            drawPie("IndustryPie", pie_data[0], "#pie_chart_1 .chart", 10, 100, 0, 0)
            drawPie("StatusPie", pie_data[1], "#pie_chart_2 .chart", 10, 100, 0, 0);
            drawPie("InterventionPie", pie_data[2], "#pie_chart_3 .chart", 10, 100, 0, 0)

            function filterData() {
                var selected = [];
                var industry_select = [];
                var status_select = [];
                var intervention_select = [];
                var oldData = data;

                d3.selectAll(".checks").each(function (d) {
                    check = d3.select(this);

                    if (check.property("checked")) {

                        if (check.property("value") == "Sponsor_Type") {
                            if (check.property("name") == "Industry") {
                                industry_select.push(check.property("name"));
                            } else {
                                industry_select.push("Other");
                                industry_select.push("U.S. Gov");
                            };

                        } else if (check.property("value") == "Status") {
                            status_select.push(check.property("name"));
                        } else if (check.property("value") == "Intervention_Types") {
                            intervention_select.push(check.property("name"));
                        };
                        selected.push(check.property("name"));
                    }


                });
                console.log("industries:", industry_select);
                console.log("statuses:", status_select);
                console.log("interventions:", intervention_select);
                console.log("selected: ", selected)

                var newlist = [];


                if (selected.length > 0) {
                    // console.log("Selected; ", selected)
                    newData = data.filter(function (d, i) {
                        var multi = [];

                        if (d.Intervention_Types !== undefined) {
                            // console.log("Intervention: ", d.Intervention_Types, typeof(d.Intervention_Types))
                            var multi = d.Intervention_Types.split(",");
                            //console.log("MULTI: ", multi);
                        }


                        if ((industry_select.indexOf(d.Sponsor_Type) !== -1 || industry_select.length == 0)
                            && (status_select.indexOf(d.Status) !== -1 || status_select.length == 0)) {
                            if (multi.length !== 0) {
                                if (intervention_select.some(item => (multi.indexOf(item) >= 0)) || intervention_select.length == 0) {
                                    // console.log(multi.some(item => (intervention_select.includes(item))));
                                    // console.log("Intervention and multi compare: ", intervention_select, ",", multi)
                                    newlist.push(d)
                                    return newlist
                                }
                            } else if ((intervention_select.indexOf(d.Intervention_Types) !== -1 || intervention_select.length == 0)) {
                                newlist.push(d)
                                return newlist
                            }
                        } else {
                            return
                        }
                    });

                } else {
                    newData = data;
                }

                if (newData.length==0){
                    window.alert("No data");
                    console.log("OLD ", oldData)
                    return oldData;
                }
                else {
                    console.log("NEW data for the end :", newData)
                    return newData;
                }

                
                
            }// end of filter data

            function updateTable(newData) {

                

                    newData.unshift({ "Status": "", "Sponsor_Type": "", "Intervention_Types": "" })
                    var columns = ["Sponsor", "Sponsor Type", "Interventions", "Intervention Types", "Status", "NCT", "Start Year", "Title", "Phase", "Primary Outcome"]
                    console.log("The table data is: ", newData);
                    thead = table.selectAll("th")
                        .data(columns).enter()
                        .append("th")
                        .text(function (d) {
                            //console.log(d);
                            return d;
                        })
                        .append("i")
                        .attr("class", "fas fa-sort")

                    thead.on("click", function (d, i) {
                        return sortTable(i);
                    })

                    newRows = table.selectAll("tr")
                        .data(newData, function (d) {
                            //console.log("d for table row is ", d);
                            return d;
                        })

                    newRows.enter()
                        .append("tr")
                        .attr("class", function (d) {
                            // console.log("assign CLASS!!!!!!!!!", d)
                            if (d.Sponsor_Type=="" && d.Intervention_Types == "" && d.Status=="") {
                                
                                return "empty-row";
                            } else {
                                return;
                            }
                        })
                        
                        // .append("hr")
                        .selectAll("td")
                        .data(function (row) {
                            return data.columns.map(function (column) {
                                return {
                                    column: column,
                                    value: row[column]
                                };
                            })
                        })
                        .enter()
                        .append("td")
                        .append("div")
                        .attr("class", "scrollable")
                        .text(function (d) {
                            //console.log("the cell text is: ", d);
                            return d.value;
                        });
                    newRows.exit()
                        .remove();



                    newRows.exit()
                        .remove();

                

            }; // end of create table

            function sortTable(n) {
                console.log("made it into sortTable")
                var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
                table = document.getElementById("main-table");
                console.log("Table: ", table)
                switching = true;
                // Set the sorting direction to ascending:
                dir = "asc";
                /* Make a loop that will continue until
                no switching has been done: */
                while (switching) {
                    // Start by saying: no switching is done:
                    switching = false;
                    rows = table.rows;
                    /* Loop through all table rows (except the
                    first, which contains table headers): */
                    for (i = 1; i < (rows.length - 1); i++) {
                        // Start by saying there should be no switching:
                        shouldSwitch = false;
                        /* Get the two elements you want to compare,
                        one from current row and one from the next: */
                        x = rows[i].getElementsByTagName("TD")[n];
                        y = rows[i + 1].getElementsByTagName("TD")[n];
                        /* Check if the two rows should switch place,
                        based on the direction, asc or desc: */
                        if (dir == "asc") {
                            if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
                                // If so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        } else if (dir == "desc") {
                            if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
                                // If so, mark as a switch and break the loop:
                                shouldSwitch = true;
                                break;
                            }
                        }
                    }
                    if (shouldSwitch) {
                        /* If a switch has been marked, make the switch
                        and mark that a switch has been done: */
                        rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                        switching = true;
                        // Each time a switch is done, increase this count by 1:
                        switchcount++;
                    } else {
                        /* If no switching has been done AND the direction is "asc",
                        set the direction to "desc" and run the while loop again. */
                        if (switchcount == 0 && dir == "asc") {
                            dir = "desc";
                            switching = true;
                        }
                    }
                }
            } // end of sort table

            function createPieDataSets(data) {
                var status = {};
                console.log("DATA in pie data: ", data)
                for (i = 0; i < data.length; i++) {
                    if (data[i].Status in status) {
                        status[data[i].Status] += 1;
                    } else {
                        status[data[i].Status] = 1;
                    }
                }

                var sponsors = {};
                for (i = 0; i < data.length; i++) {
                    if (data[i].Sponsor_Type in sponsors) {
                        sponsors[data[i].Sponsor_Type] += 1;
                    } else {
                        sponsors[data[i].Sponsor_Type] = 1;
                    }
                }
                // console.log("sponsors: ", sponsors)
                // console.log("status: ", status)

                var interventions = {}
                for (i = 0; i < data.length; i++) {
                    if (data[i].Intervention_Types.indexOf(',') > -1) {

                        var multi = data[i].Intervention_Types.split(", ");

                        for (var item of multi) {
                            if (item in interventions) {
                                interventions[item] += 1;
                            } else {
                                interventions[item] = 1;
                            }
                        }
                    } else if (data[i].Intervention_Types in interventions) {
                        interventions[data[i].Intervention_Types] += 1;
                    } else {
                        interventions[data[i].Intervention_Types] = 1;
                    }
                }
                //console.log(interventions)
                //console.log("intervention item: ", Object.keys(interventions), Object.values(interventions))

                sponsor_set = []
                intervention_set = []
                status_set = []


                // console.log(Object.keys(sponsors).length)
                for (var p = 0; p < Object.keys(sponsors).length; p++) {
                    var sponsor = {}
                    sponsor[Object.keys(sponsors)[p]] = Object.values(sponsors)[p];
                    sponsor_set.push(sponsor);
                }
                //console.log("HERE:", sponsor_set)

                for (var j = 0; j < Object.keys(status).length; j++) {

                    var stats = {}
                    stats[Object.keys(status)[j]] = Object.values(status)[j];
                    status_set.push(stats);
                }
                // console.log("HERE:", status_set)

                for (var k = 0; k < Object.keys(interventions).length; k++) {
                    var intervention = {}
                    intervention[Object.keys(interventions)[k]] = Object.values(interventions)[k];
                    intervention_set.push(intervention);
                    
                }
                //console.log("HERE:", intervention_set)
                
                
                // status_set.shift(0)
                // intervention_set.shift(0)
                // sponsor_set.shift(0)

                console.log("filter pie: sponsors", sponsor_set,  " statuses ", status_set, "interventions ", intervention_set)
                return ([sponsor_set, status_set, intervention_set]);
            } // end of create pie data
            
            function drawPie(pieName, dataSet, selectString, margin, outerRadius, innerRadius) {
                if (dataSet.length==0) {
                    dataSet=newData;
                    console.log("dataset: ", dataSet)
                    return;
                } else {


                    // Color Scale Handling...
                    // var colorScale = d3.scale.category20c();
                    var color = d3.scaleOrdinal(d3.schemeCategory20c);

                    if (Object.keys(dataSet[0]) == "") {
                        dataSet.shift(0);
                    }


                    console.log("data is: ", dataSet)


                    var canvasWidth = 700;
                    var pieWidthTotal = outerRadius * 2;;
                    var pieCenterX = outerRadius + margin / 2;
                    var pieCenterY = outerRadius + margin / 2;

                    var legendBulletOffset = 30;
                    var legendVerticalOffset = outerRadius - margin;
                    var legendTextOffset = 20;
                    var textVerticalSpace = 20;

                    var canvasHeight = 0;
                    var pieDrivenHeight = outerRadius * 2 + margin * 2;
                    var legendTextDrivenHeight = (dataSet.length * textVerticalSpace) + margin * 2;

                    if (pieDrivenHeight >= legendTextDrivenHeight) {
                        canvasHeight = pieDrivenHeight;
                    }
                    else {
                        canvasHeight = legendTextDrivenHeight;
                    }
                    // console.log("still have data: ", dataSet)
                    // console.log(Object.keys(dataSet).length)

                    var x = d3.scale.linear().domain([0, d3.max(dataSet, function (d) { return Object.values(d)[0]; })]).rangeRound([0, pieWidthTotal]);
                    var y = d3.scale.linear().domain([0, Object.keys(dataSet).length]).range([0, (Object.keys(dataSet).length * 20)]);


                    var tweenPie = function (b) {
                        b.innerRadius = 0;
                        var i = d3.interpolate({ startAngle: 0, endAngle: 0 }, b);
                        return function (t) {
                            return arc(i(t));
                        };
                    }

                    // Create a drawing canvas...
                    var canvas = d3.select(selectString)
                        .append("svg:svg") //create the SVG element inside the <body>
                        .data([dataSet]) //associate our data with the document
                        .attr("width", canvasWidth) //set the width of the canvas
                        .attr("height", canvasHeight) //set the height of the canvas
                        .append("svg:g") //make a group to hold our pie chart
                        .attr("transform", "translate(" + pieCenterX + "," + pieCenterY + ")") // Set center of pie

                    // Define an arc generator. This will create <path> elements for using arc data.
                    var arc = d3.svg.arc()
                        .innerRadius(innerRadius) // Causes center of pie to be hollow
                        .outerRadius(outerRadius);

                    // Define a pie layout: the pie angle encodes the value of dataSet.
                    // Since our data is in the form of a post-parsed CSV string, the
                    // values are Strings which we coerce to Numbers.
                    var pie = d3.layout.pie()
                        .value(function (d) { return Object.values(d)[0]; })





                    // Select all <g> elements with class slice (there aren't any yet)
                    var arcs = canvas.selectAll("g.slice")
                        // Associate the generated pie data (an array of arcs, each having startAngle,
                        // endAngle and value properties) 
                        .data(pie)
                        // This will create <g> elements for every "extra" data element that should be associated
                        // with a selection. The result is creating a <g> for every object in the data array
                        // Create a group to hold each slice (we will have a <path> and a <text>      // element associated with each slice)
                        .enter().append("svg:a")
                        //.attr("xlink:href", function (d) { return d.data.link; })
                        .append("svg:g")
                        .attr("class", "slice")    //allow us to style things in the slices (like text)
                        // .attr("id", function(d){

                        // })
                        // Set the color for each slice to be chosen from the color function defined above
                        // This creates the actual SVG path using the associated data (pie) with the arc drawing function
                        .style("stroke", "White")
                        .attr("d", arc);



                    arcs.append("svg:path")

                        // This creates the actual SVG path using the associated data (pie) with the arc drawing function
                        .attr("fill", function (d, i) { return color(i); })
                        .attr("color_value", function (d, i) { return color(i); }) // Bar fill color...
                        .attr("index_value", function (d, i) { return "index-" + i; })
                        .attr("class", function (d, i) { return "pie-" + pieName + "-arc-index-" + i; })
                        .style("stroke", "White")
                        .attr("d", arc)
                        // .on('mouseover', synchronizedMouseOver)
                        // .on("mouseout", synchronizedMouseOut)

                        .on("mouseover", function (d) {
                            // console.log("Over: ", Object.keys(d.data)[0])
                            div.transition()
                                .duration(200)
                                .style("opacity", .9);
                            // console.log("Post transition")
                            div.html("Type: " + Object.keys(d.data)[0] + "<br/> Total: " + Object.values(d.data)[0])
                                .style("left", (d3.event.pageX) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");
                        })
                        .on("mouseout", function (d) {
                            // console.log("Off: ", d.data)
                            div.transition()
                                .duration(500)
                                .style("opacity", 0);
                        })
                        .transition()
                        .duration(1500)
                        .delay(function (d, i) { return i * 50; })
                        .attrTween("d", tweenPie);

                

                    // Computes the angle of an arc, converting from radians to degrees.
                    function angle(d) {
                        var a = (d.startAngle + d.endAngle) * 90 / Math.PI - 90;
                        return a > 90 ? a - 180 : a;
                    }



                    var legend = canvas.selectAll(".legend")
                        .data(color.domain())
                        .enter()
                        .append("g")
                        .attr("class", "legend")

                    legend.selectAll("rect")
                        .data(dataSet)
                        .enter()
                        .append("rect")
                        .attr("width", 10)
                        .attr("height", 10)
                        .attr("x", function (d, i) {
                            return 110;
                        })
                        .attr("y", function (d, i) {
                            return (i * 20) - 60;
                        })
                        .attr("class", function (d, i) {

                            if (Object.keys(d)[0] == "") {

                                return "legend0";
                            } else {
                                return "non-legend";
                            }

                        })
                        .style("fill", function (d, i) {
                            return color(i)
                        });
                    // .style("stroke", "black");

                    legend.selectAll("text")
                        .data(dataSet)
                        .enter()
                        .append("text")
                        .attr("x", function (d, i) {
                            return 120;
                        })
                        .attr("y", function (d, i) {
                            return (i * 20) - 50;
                        })
                        .text(function (d) {
                            //console.log("Legend text: ", Object.keys(d)[0])
                            return Object.keys(d)[0];
                        })
                        .style("font-size", 12)


                    // .on('mouseover', synchronizedMouseOver)
                    // .on("mouseout", synchronizedMouseOut);


                    // console.log("preparing for click")
                    arcs.on("click", function (d, i) {
                        //  console.log("Made it in here and d is :", d);
                        // filter on this object
                        //  console.log(Object.keys(d.data)[0])
                        //   console.log("I in on click ", i)
                        //   console.log("d in onclick ", d)


                        var input = Object.keys(d.data)[0];
                        //  console.log("input: ", input);

                        if (pie_clicked.length > 1) {
                            pie_clicked = [];
                        }



                        if (pie_clicked.indexOf(input) == -1) {
                            pie_clicked.push(input);
                        } else {
                            pie_clicked = pie_clicked.filter(function (d) {
                                return d !== input;
                            })
                        }
                        console.log("PIE CLICKED: ", pie_clicked);


                        var newdata = filterPie(pie_clicked)

                        // console.log("new data for pie: ", newdata)
                        var new_pie = createPieDataSets(newdata);

                        d3.selectAll(".chart").remove();
                        d3.selectAll(".div_RootBody").append("div").attr("class", "chart");


                        drawPie("IndustryPie", new_pie[0], "#pie_chart_1 .chart", 10, 100, 0, 0)
                        drawPie("IndustryPie", new_pie[1], "#pie_chart_2 .chart", 10, 100, 0, 0)
                        drawPie("IndustryPie", new_pie[2], "#pie_chart_3 .chart", 10, 100, 0, 0)

                        //newData.unshift({ "Status": "", "Sponsor_Type": "", "Intervention_Types": "" })
                        updateTable(newData);


                    })
                }
            }; // end of drawPie


                

            function filterPie(filterOn) {
                //  console.log("In filter pie!!!!!!")
                console.log("Filter on: ", filterOn)
                if (filterOn.length==0){
                    newData = data;
                }
                else if (filterOn.length > 1) {
                    newData = data.filter(function (d, i) {
                        if ((d.Status == filterOn[0] || d.Intervention_Types == filterOn[0] || d.Sponsor_Type == filterOn[0]) && (d.Status == filterOn[1] || d.Intervention_Types == filterOn[1] || d.Sponsor_Type == filterOn[1])) {
                            return d;
                        } else {
                            return;
                        }
                    })
                } else {
                    newData = data.filter(function (d, i) {
                        if (d.Status == filterOn || d.Intervention_Types == filterOn || d.Sponsor_Type == filterOn) {
                            return d;
                        } else {
                            return;
                        }
                    });
                }


                console.log("new Data in filter on: ", newData);
                return newData;



            } // end of filter Pie

            function runall() {

                d3.selectAll(".chart").remove();
                d3.selectAll(".div_RootBody").append("div").attr("class", "chart");

                updated = filterData();
                if (updated.length == 0){
                    window.alert("There are no trials matching your selection")
                    return;
                } else {
                    updateTable(updated);
                    updated.shift()
                    console.log("UPDATED NEW removed: ", updated)
                    var pie_data = createPieDataSets(updated);
                    drawPie("IndustryPie", pie_data[0], "#pie_chart_1 .chart", 10, 100, 0, 0)
                    drawPie("StatusPie", pie_data[1], "#pie_chart_2 .chart", 10, 100, 0, 0);
                    drawPie("InterventionPie", pie_data[2], "#pie_chart_3 .chart", 10, 100, 0, 0)
                }
                
            }

            
        });



            


    </script>
    




    </html>